/**********************************************************************
 **                                                                  **
 **                           database.cnl                           **
 **                                                                  **
 **                                                                  **
 **  Written by:  Douglas C. MacKenzie                               **
 **               Jonathan M. Cameron                                **
 **                                                                  **
 **  Copyright 1995 - 2006, Georgia Tech Research Corporation        **
 **  Atlanta, Georgia  30332-0415                                    **
 **  ALL RIGHTS RESERVED, See file COPYRIGHT for details.            **
 **                                                                  **
 **********************************************************************/

/* $Id: DATABASE.cnl,v 1.1.1.1 2006/07/12 13:37:58 endo Exp $ */


#include "cnl.inc"


/***********************************************************************/

procedure double DATABASE_DOUBLE with
   CNLString_t key;
   double initial;
header
   char   *value;
   char   *ptr;
   double  old_value = 0;
   int     first_time = TRUE;
body

   if( first_time )
     {
        old_value = initial;
        first_time = FALSE;
     }

   if( (value=get_state(key.val)) != NULL )
     {
       /* The value has been updated so read the new value */
       output = strtod(value,&ptr);
       if( ptr == value || ptr == NULL || *ptr != '\0' ) 
       {

	     if(debug) fprintf(stderr,
		    "Robot (%d): Badly formed number in DATABASE_DOUBLE %s: '%s'\n", 
		    robot_id, key.val, value);
	     output = old_value;
       }
       else
       {
	     old_value = output;
         if( debug )
	     {
           fprintf(stderr,"Robot(%d): DATABASE_DOUBLE - New value %f for %s\n",
		   robot_id, output, key.val);
         }
       }
     }
   else
     {
        /* The value has NOT been updated so reuse the old value */
        output = old_value;
     }

   if( debug )
     {
        fprintf(stderr,"Robot(%d): DATABASE_DOUBLE: Returning value %f for %s\n",
		   robot_id, output, key.val);
     }

 
   if( debug )
     {
       fprintf(stderr,"Robot(%d): DATABASE_DOUBLE: Returning value %f for %s\n",
		   robot_id, output, key.val);
     }

pend

/***********************************************************************/
// This CNL procedure updates the local copy of the database_double
// To simplify using in CDL on a transition, this procedure outputs true.
/***********************************************************************/

procedure bool SET_DATABASE_DOUBLE with
   CNLString_t  key;
   double  value;
header
   char   valstr[80];
body
   // Always return true.
   output = true;

   // Write the value to a database value string
   sprintf(valstr, "%g", value);

   // update the database.
   put_state(key.val, valstr);

   if( debug )
   {
       fprintf(stderr,"Robot(%d): SET_DATABASE_DOUBLE - set key %s to value %s\n", 
	       robot_id, key.val, valstr);
   }

pend


/***********************************************************************/

procedure int DATABASE_INT with
   CNLString_t  key;
   int     initial;
header
   char         *value;
   char         *ptr;
   int          old_value = 0;
   int          first_time = TRUE;
body

   if( first_time )
     {
        old_value = initial;
        first_time = FALSE;
     }

   if( (value=get_state(key.val)) != NULL )
     {
       /* The value has been updated so read the new value */
       output = (int)(strtol(value,&ptr,10));
       if( ptr == value || ptr == NULL || *ptr != '\0' ) 
       {
	 if(debug) fprintf(stderr,"Robot (%d): Badly formed number in DATABASE_INT: '%s'\n", robot_id, key.val);
	 output = old_value;
       }
       else
       {
	     old_value = output;
         if( debug )
	     {
           fprintf(stderr,"Robot(%d): DATABASE_INT - New value %d for %s\n",
		   robot_id, output, key.val);
         }
       }
     }
   else
     {
        /* The value has NOT been updated so reuse the old value */
        output = old_value;
     }

   if( debug )
     {
        fprintf(stderr,"Robot(%d): DATABASE_INT: Returning value %d for %s\n",
		   robot_id, output, key.val);
     }

 
   if( debug )
     {
       fprintf(stderr,"Robot(%d): DATABASE_INT: Returning value %d for %s\n",
		   robot_id, output, key.val);
     }

pend

/***********************************************************************/

procedure bool DATABASE_BOOLEAN with
   CNLString_t  key;
   bool  initial;
header
   char         *value;
   char         *ptr;
   int          old_value = 0;
   int          first_time = TRUE;
body
{
    if( first_time )
    {
        old_value = initial;
        first_time = FALSE;
    }

    if( (value=get_state(key.val)) != NULL )
    {
        /* The value has been updated so read the new value */
        output = (const boolean)(strtol(value,&ptr,10));
        if( ptr == value || ptr == NULL || *ptr != '\0' ) 
        {
            if(debug)
            {
                fprintf(stderr, "Robot (%d): Badly formed number in DATABASE_BOOLEAN: '%s'\n", robot_id, key.val);
            }
            output = old_value;
        }
        else
        {
            old_value = output;
            if( debug )
            {
                fprintf(stderr,"Robot(%d): DATABASE_BOOLEAN - New value %d for %s\n",
                        robot_id, output, key.val);
            }
        }
    }
    else
    {
        /* The value has NOT been updated so reuse the old value */
        output = old_value;
    }

    if( debug )
    {
        fprintf(stderr,"Robot(%d): DATABASE_BOOLEAN: Returning value %s for %s\n",
                robot_id, output ? "true" : "false", key.val);
    }
}
pend

/***********************************************************************/
// This CNL procedure (in tandam with UPDATE_DISTRIBUTED_FLAG) maintains a 
// boolean value, distributed between all the robots and the missionlab console.
procedure bool TEST_DISTRIBUTED_FLAG with
   CNLString_t  key;
   bool    default_value;
header
   char   *value;
body
   // See if there is a value in the database
   if( ((value = get_state(key.val)) != NULL) && (value[0] != '\0' ) )
   {
fprintf(stderr,"Robot(%d): TEST_DISTRIBUTED_FLAG(%s): Got '%s'\n", robot_id, key.val, value);

      // Yes, return it.
      output = value[0] == 't';
   }
   else
   {
fprintf(stderr,"Robot(%d): TEST_DISTRIBUTED_FLAG(%s): didn't get it\n", robot_id, key.val);
      // No, return the default.
      output = default_value;
   }

   if( debug )
   {
      fprintf(stderr,"Robot(%d): TEST_DISTRIBUTED_FLAG: Returning value %s for %s\n",
		   robot_id, output ? "true" : "false", key.val);
   }
fprintf(stderr,"Robot(%d): TEST_DISTRIBUTED_FLAG: Returning value %s for %s\n",
		   robot_id, output ? "true" : "false", key.val);
pend

/***********************************************************************/
// This CNL procedure (in tandam with TEST_DISTRIBUTED_FLAG) maintains a 
// boolean value, distributed between all the robots and the missionlab console.

// To simplify using in CDL on a transition, this procedure outputs true.

procedure bool UPDATE_DISTRIBUTED_FLAG with
   CNLString_t  key;
   bool    value;
header
   char   valstr[80];
body
   // Always return true.
	output = true;

   // Use LISP notation for true/false in the database value string
	valstr[0] = value ? 't' : 'f';

   // broadcast it.
   exec_broadcast_value(key.val, valstr, THIS_ROBOT);

   if( debug )
   {
      fprintf(stderr,"Robot(%d): UPDATE_DISTRIBUTED_FLAG(%d): updating key %s to value %c\n", robot_id, value, key.val, valstr[0]);
   }
fprintf(stderr,"Robot(%d): UPDATE_DISTRIBUTED_FLAG(%d): updating key %s to value %c\n", robot_id, value, key.val, valstr[0]);
pend


/**********************************************************************
# $Log: DATABASE.cnl,v $
# Revision 1.1.1.1  2006/07/12 13:37:58  endo
# MissionLab 7.0
#
# Revision 1.3  2006/02/19 17:54:53  endo
# Experiment related modifications
#
# Revision 1.2  2006/01/10 06:16:04  endo
# AO-FNC Type-I check-in.
#
# Revision 1.1.1.1  2005/02/06 22:59:55  endo
# AO-FNC Project (based on mlab-6.0.01.06192003.tar.gz)
#
# Revision 1.16  2002/01/13 01:43:35  endo
# SET_DATABASE_DOUBLE added.
#
# Revision 1.15  2000/10/16 19:21:31  endo
# Modified due to the compiler upgrade.
#
# Revision 1.14  2000/06/13 16:55:44  endo
# THIS_ROBOT added as an input of exec_broadcast_value().
#
# Revision 1.13  2000/04/16 15:53:02  endo
# DATABASE_INT DATABASE_BOOLEAN modified like the way
# DATABASE_DOUBLE.
#
# Revision 1.12  2000/04/13 22:30:34  endo
# Checked in for Doug.
# TEST_DISTRIBUTED_FLAG added.
#
# Revision 1.11  2000/03/30 01:28:01  endo
# Made saho's patch to be applicable to others.
#
# Revision 1.10  2000/03/24 17:03:23  saho
# Made a patch for the emotional variables. Currently all variables
# are being reset once a trigger is reentered. This menas that varaiables
# usially have their default values most of the time.
# A better solution than the strcmp() is needed but I did not want
# to change the existing functionality.
#
# Revision 1.9  1996/06/05  20:27:37  doug
# added SCALE_VECTOR
#
# Revision 1.8  1995/09/08  16:13:42  doug
# database_boolean should return a bool
#
# Revision 1.7  1995/09/08  14:50:10  doug
# removed include of gt_simulation.h since now in cnl.inc
#
# Revision 1.6  1995/06/28  21:49:32  jmc
# Added RCS log string.
#**********************************************************************/
