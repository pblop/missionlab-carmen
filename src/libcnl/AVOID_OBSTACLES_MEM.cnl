/*--------------------------------------------------------------------

	AVOID_OBSTACLES_MEM.cnl


	Written by:  Doug MacKenzie

	Copyright 1995, Georgia Tech Research Corporation
	Atlanta, Georgia  30332-0415
	ALL RIGHTS RESERVED, See file COPYRIGHT for details.

--------------------------------------------------------------------*/

#include "cnl.inc"
init
#include <stdio.h>
#include <math.h>
#include "gt_std_types.h"

#define NUM_SECTORS 32
#define SONAR_FOV 20
#define SONAR_LIFE 10000

struct t_sector{
  double dist;
  int age;
};


double inrangeAngle(double ang){
  while(ang < 0) ang += 360;
  while(ang >= 360) ang -= 360;
  return ang;
}


// Return angle [0..360) of vector.
double vectorAngle(Vector v){

  double radAng;
  double degAng;

  radAng = atan2(v.y,v.x);
  degAng = radAng * 180/M_PI;

  degAng = inrangeAngle(degAng);
  return(degAng);
}


void setSectors(t_sector sector[],int num_sectors,double angle,double dist,double fov){
  double degPerSector = 360.0/num_sectors;
  int start,finish,index,i;

  start = floor(inrangeAngle(angle - fov/2.0)/360.0*double(num_sectors));
  finish = floor(inrangeAngle(angle + fov/2.0)/360.0*double(num_sectors));
  
  if (start<finish) {
    for(i=start;i<=finish;i++){
      index = i % num_sectors;
      if (dist<sector[index].dist) {
	sector[index].dist = dist;
	sector[index].age = 0;
      }
    }
  }
  else {
    for(i=start;i<num_sectors;i++){
      index = i % num_sectors;
      if (dist<sector[index].dist) {
	sector[index].dist = dist;
	sector[index].age = 0;
      }
    }
    for(i=0;i<=finish;i++){
      index = i % num_sectors;
      if (dist<sector[index].dist) {
	sector[index].dist = dist;
	sector[index].age = 0;
      }
    }
  }
}


iend

/***********************************************************************/

procedure Vector AVOID_OBSTACLES_MEM with
   double	sphere;
   double	safety_margin;
   double       decay_rate;
   obs_array    readings;
   robot_position cur_pos;
header
   int          first_time=TRUE; 
   double       old_safety_margin = 0;
body
  if( first_time || old_safety_margin != safety_margin )
   {
      /* 
       * Report the safety margin we are using to the console so the
       * graphics can use it for showing virtual collisions
       */
      char buf[80];

      sprintf(buf, "%f",safety_margin);
      exec_put_console_state(SAFETY_MARGIN_MSG,buf);
      
      old_safety_margin = safety_margin;
      first_time = FALSE;
   }

  VECTOR_CLEAR(output);

  static t_sector sector[NUM_SECTORS];
  static int initialized = 0;
  double degPerSector = 360.0/double(NUM_SECTORS);
  double radPerSector = 2.0*M_PI/double(NUM_SECTORS);
  Vector v;
  double objAngle,objDist;
  double rad_heading = (2.0*M_PI)/360.0*cur_pos.heading;

  if (!initialized) {
    for(int i=0;i<NUM_SECTORS;i++){
      sector[i].dist = GT_INFINITY;
      sector[i].age = GT_INFINITY;
    }
    initialized = 1;
  }

  fprintf(stderr,"AVOID_OBJECTS_MEM(sphere = %.1f, safety_margin = %.1f\n",
	  sphere, safety_margin);
  
  fprintf(stderr,"LOCATION <%.1f %.1f> %.1f\n",cur_pos.v.x,cur_pos.v.y,cur_pos.heading);

  // For each object
  for(int i=0; i<readings.size; i++){
    v.x = readings.val[i].center.x;
    v.y = readings.val[i].center.y;
    objDist = len_2d(v);
    rotate_z(v,cur_pos.heading);
    objAngle = vectorAngle(v);
    setSectors(sector,NUM_SECTORS,objAngle,objDist,SONAR_FOV);
  }

  for(int i=0;i<NUM_SECTORS;i++){
    sector[i].age++;
    sector[i].dist += decay_rate;
    if (sector[i].age > SONAR_LIFE) sector[i].dist = GT_INFINITY;
  };

  VECTOR_CLEAR(v);
  double mag=0,ang;
  ObstacleReadings msg;
  msg.obs = (gt_Point *)calloc(sizeof(gt_Point) * NUM_SECTORS, 1);
  msg.num_obs = NUM_SECTORS;
  msg.robot_id = robot_id;

  for(int i=0;i<NUM_SECTORS;i++){
    mag = 0;
    ang = radPerSector*i + radPerSector/2.0;
    if (sector[i].dist < safety_margin) mag = GT_INFINITY;
    else if (sector[i].dist <= safety_margin + sphere) {
      mag = (sphere - (sector[i].dist - safety_margin)) / sphere;
    }
    v.x -= mag*cos(ang);
    v.y -= mag*sin(ang);
    msg.obs[i].x = sector[i].dist*cos(ang-rad_heading);
    msg.obs[i].y = sector[i].dist*sin(ang-rad_heading);
  }

  //exec_report_sonars(&msg);
  rotate_z(v,-cur_pos.heading);
  output = v;
 
   fprintf(stderr,"AVOID_OBJECTS_MEM: output vector <%.1f %.1f>\n",
	 output.x, output.y);
	 
pend


