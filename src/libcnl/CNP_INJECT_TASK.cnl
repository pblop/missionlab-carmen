/**********************************************************************
 **                                                                  **
 **                       CNP_INJECT_TASK.cnl                        **
 **                                                                  **
 **  Written by:  Yoichiro Endo                                      **
 **                                                                  **
 **  CNP_INJECT_TASK injects a task.                                 **
 **                                                                  **
 **  Format of constraintsString:                                    **
 **                                                                  **
 **  (1) name1:type1:value1,name2:type2:value2,... or                **
 **                                                                  **
 **  (2) name1:type1:value1                                          **
 **      name2:type2:value2                                          **
 **      ...                                                         **
 **                                                                  **
 **  type is defined in src/cnp/cnp_constants.h                      **
 **                                                                  **
 **  Copyright 2005 - 2006, Georgia Tech Research Corporation        **
 **  Atlanta, Georgia  30332-0415                                    **
 **  ALL RIGHTS RESERVED, See file COPYRIGHT for details.            **
 **                                                                  **
 **********************************************************************/

/* $Id: CNP_INJECT_TASK.cnl,v 1.1.1.1 2006/07/12 13:37:58 endo Exp $ */

#include "cnl.inc"

init
#include <vector>
#include <string>
// ENDO - gcc 3.4
//#include "cnp_server_manager.h"
//#include "cnp_constants.h"
#include "CNPConstraint.h"

using std::vector;
using std::string;
iend

/***********************************************************************/

procedure Vector CNP_INJECT_TASK with
   int taskID; // Number
   CNLString_t taskName; // Name of the task, not a constraint name.
   CNLString_t constraintsString; // Format: see the comment in the header above,
header
   bool firstTime = true;
body
{
    vector<CNP_TaskConstraint> cnpTaskConstraints;
    CNP_TaskConstraint cnpTaskConstraint; 
    string bufString, subBufString;
    string name, value, typeString, key;
    string::size_type colonIndex1, colonIndex2;
    string::size_type spaceIndex;
    string::size_type commaIndex;
    string::size_type newlineIndex;
    string::size_type separatorIndex;
    char *data;
    int i, subBufSize;
    int constraintType;
    int errorNum = 0;
    bool hadError = false;

    VECTOR_CLEAR(output);

    if (firstTime)
    {
        cnpTaskConstraint.taskInfo.id = taskID;
        cnpTaskConstraint.taskInfo.name = taskName.val;

        bufString = constraintsString.val;

        // Delete white spaces
        while (true)
        {
            spaceIndex = bufString.find_first_of(' ');

            if (spaceIndex == string::npos)
            {
                // Done searching.
                break;
            }

            // Get the string after the space
            subBufString = bufString.substr(spaceIndex+1, string::npos);

            // Get the string before the string
            bufString = bufString.substr(0, spaceIndex);

            // Combine the two
            bufString += subBufString; 
        }

        while(true)
        {
            // Find ','.
            commaIndex = bufString.find(',');

            // Find '\n'.
            newlineIndex = bufString.find('\n');

            // Pick which ever comes first.
            if (commaIndex <= newlineIndex)
            {
                separatorIndex = commaIndex;
            }
            else
            {
                separatorIndex = newlineIndex;
            }

            if (separatorIndex == string::npos)
            {
                // No more ',' or '\n' (i.e., the last set).
                subBufString = bufString;
            }
            else
            {
                // Get the string before ','.
                subBufString = bufString.substr(0, separatorIndex);
            }

            // Check the size.
            subBufSize = subBufString.size();

            if (subBufSize == 0)
            {
                if (separatorIndex == string::npos)
                {
                    // It was perhaps already at the end. Finish it.
                    break;
                }

                // Move on to the next set.
                bufString = bufString.substr(separatorIndex+1, string::npos);
                continue;
            }

            // Find ':'.
            colonIndex1 = subBufString.find_first_of(':');
            colonIndex2 = subBufString.find_last_of(':');

            if ((colonIndex1 == string::npos) || (colonIndex2 == string::npos))
            {
                errorNum = 1;
                hadError = true;
                break;
            }

            // Get the constraint name and value.
            name = subBufString.substr(0, colonIndex1);
            typeString = subBufString.substr(colonIndex1+1, colonIndex2-colonIndex1-1);
            constraintType = atoi(typeString.c_str());
            value = subBufString.substr(colonIndex2+1, string::npos);

            if (((int)(name.size()) == 0) ||
                ((int)(typeString.size()) == 0) ||
                ((int)(value.size()) == 0))
            {
                errorNum = 2;
                hadError = true;
                break;
            }

            if (value == "*")
            {
                // Dynamic constraint. Check database.
                value = CNL_EMPTY_STRING;
                i = 0;
                while (true)
                {
                    if (CONSTRAINT_DATABASE_KEY_MAP[i].constraintName ==
                        CNL_EMPTY_STRING)
                    {
                        // Entry not found in CONSTRAINT_DATABASE_KEY_MAP.
                        break;
                    }
                    
                    if (CONSTRAINT_DATABASE_KEY_MAP[i].constraintName == name)
                    {
                        key = CONSTRAINT_DATABASE_KEY_MAP[i].dataBaseKey;

                        data = get_state((char *)(key.c_str()));

                        if (data != NULL)
                        {
                            // Entry found in the database.
                            value = data;
                        }

                        break;
                    }
                    i++;
                }
            }

            if (value != CNL_EMPTY_STRING)
            {
                // Save them in the list.
                cnpTaskConstraint.strConstraintName = name;
                cnpTaskConstraint.constraintType = (CNP_ConstraintType)constraintType;
                cnpTaskConstraint.strConstraintValue = value;
                cnpTaskConstraints.push_back(cnpTaskConstraint);
            }

            if (bufString == subBufString)
            {
                // Done
                break;
            }
            else if ((int)(bufString.size()) >= (subBufSize+1))
            {
                // Move on to the next set.
                bufString = bufString.substr(subBufSize+1, string::npos);
            }
            else
            {
                // Had error
                errorNum = 3;
                hadError = true;
                break;
            }
        }

        if (hadError)
        {
            fprintf(stderr, "Warning: Error(%d) in CNP_INJECT_TASK.cnl\n", errorNum);
        }
        else
        {
            // Call the function in robot_side_com.c
            exec_send_cnp_task_constraints(cnpTaskConstraints);
        }

        firstTime = false;
    }
}
pend

/**********************************************************************
# $Log: CNP_INJECT_TASK.cnl,v $
# Revision 1.1.1.1  2006/07/12 13:37:58  endo
# MissionLab 7.0
#
# Revision 1.5  2006/05/15 02:48:49  endo
# gcc-3.4 upgrade
#
# Revision 1.4  2006/05/02 04:17:18  endo
# TrackTask improved for the experiment.
#
# Revision 1.3  2006/03/01 09:27:39  endo
# Check-in for Type-I Intercept Experiment.
#
# Revision 1.2  2006/02/19 22:41:33  endo
# CNP_SAVE_TARGET_LOCATION stuff.
#
# Revision 1.1  2006/01/10 06:19:44  endo
# AO-FNC Type-I check-in.
#
#**********************************************************************/
