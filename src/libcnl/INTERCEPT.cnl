/**********************************************************************
 **                                                                  **
 **                          INTERCEPT.cnl                           **
 **                                                                  **
 **  Written by: Yoichiro Endo                                       **
 **                                                                  **
 **  Copyright 2005, Georgia Tech Research Corporation               **
 **  Atlanta, Georgia  30332-0415                                    **
 **  ALL RIGHTS RESERVED, See file COPYRIGHT for details.            **
 **                                                                  **
 **********************************************************************/

/* $Id: INTERCEPT.cnl,v 1.1.1.1 2006/07/12 13:37:58 endo Exp $ */

#include "cnl.inc"

procedure Vector INTERCEPT with
    ObjectList objlist;
header
    const int NUM_BUFFER = 5;
    bool firstTime = true;
    bool bufferFilled = false;
    double last_xo = 0; 
    double last_yo = 0; 
    double last_xr = 0; 
    double last_yr = 0; 
    double last_thr = 0;
    double voBuf[NUM_BUFFER], vrBuf[NUM_BUFFER];
    int bufIndex = 0;
body
{
    // --------------------------------------------------------------------
    // Notation:
    // <xo, yo> = object (enemy) [known]
    // <xr, yr> = robot (self) [known]
    // <xc, yc> = collision point [unknown]
    // vo = speed of the object (enemy) [known]
    // tho = angle of the object (enemy) [unknown]
    // vr = speed of the robot (self) [known]
    // thr = desired angle of the robot (self) [unknown]
    // tc = time for the collision [unknown]
    //
    // Equations to solve (4 equations 4 unknown):
    // xc = vo*tc*cos(tho) + xo
    // yc = vo*tc*sin(tho) + yo
    // xc = vr*tc*cos(thr) + xr
    // yc = vr*tc*sin(thr) + yr
    //
    // The equation would be reduced to (1 unknown: thr):
    // (vo*sin(tho)-vr*sin(thr))*(xo-xr)=(vo*cos(tho)-vr*cos(thr))*(yo-yr)
    //
    // However, solving this is hard since it contains sin and cos.
    // So, here we check the possible angles for thr, and see which
    // angle makes the LHS and RHS be the closest.
    //
    // If that fails, choose a vector pointing towards the object
    // (i.e., MoveTo).
    //
    // --------------------------------------------------------------------

    //const double MIN_VALUE = 0.01;
    const double MIN_VALUE = 1.0;
    const double MAX_VALUE = 1.0;
    const double MIN_DIFF = 1.0;

    robot_position cur_pos;
    Vector objVec;
    double xo, yo, xr, yr, vo, tho, vr, thr, tc;
    double LHS, RHS;
    double dist, closestDist;
    double diff, smallestDiff;
    double bestThr, checkValue;
    double objDirDeg, objDirRad;
    double a;
    int i, closestIndex;
    const bool USE_ANALYTICAL = true;
    const bool DEBUG_INTERCEPT = false;

    VECTOR_CLEAR(output);

    // Get the robot position
    cur_pos = exec_get_position();
    xr = cur_pos.v.x;
    yr = cur_pos.v.y;

    // Get the closest object (enemy)
    if (objlist.count > 0)
    {
        closestIndex = 0;
        closestDist = 0;

        closestDist = objlist.objects[0].distance(0, 0);

        for (i = 1; i < objlist.count; i++)
        {
            dist = objlist.objects[i].distance(0, 0);

            if (dist < closestDist)
            {
                closestDist = dist;
                closestIndex = i;
            }
        }
    
        ObjectReading closestObj(objlist.objects[closestIndex]);
        VECTOR_CLEAR(objVec);
        objVec.x = closestObj.x1;
        objVec.y = closestObj.y1;
        rotate_z(objVec, cur_pos.heading);
        xo = objVec.x + xr;
        yo = objVec.y + yr;
        objDirRad = atan2(objVec.y, objVec.x);
        objDirDeg = RADIANS_TO_DEGREES(objDirRad);
        bestThr = objDirRad;

        if (firstTime)
        {
            memset(voBuf, 0x0, sizeof(double)*NUM_BUFFER);
            memset(vrBuf, 0x0, sizeof(double)*NUM_BUFFER);
            last_thr = objDirRad;
            firstTime = false;
        }
        else
        {
            // Get the velocities and angles
            vo = sqrt(pow(xo-last_xo, 2) + pow(yo-last_yo, 2));
            vr = sqrt(pow(xr-last_xr, 2) + pow(yr-last_yr, 2));
            tho = atan2(yo-last_yo, xo-last_xo);

            // Fill the velocity buffers with the values.
            voBuf[bufIndex] = vo;
            vrBuf[bufIndex] = vr;
            bufIndex++;

            if (bufIndex >= NUM_BUFFER)
            {
                bufIndex = 0;
                bufferFilled = true;
            }

            if (bufferFilled)
            {
                // Compute the average velocity of the object and robot in the past.
                vo = 0;
                vr = 0;

                for (i = 0; i < NUM_BUFFER; i++)
                {
                    vo += (voBuf[i]/NUM_BUFFER);
                    vr += (vrBuf[i]/NUM_BUFFER);
                }

                // Check to see if the last thr can be recycled. If it can, this
                // will stabilize the heading as well reduce the computation time.
                thr = last_thr;
                LHS = (vo*sin(tho)-vr*sin(thr))*(xo-xr);
                RHS = (vo*cos(tho)-vr*cos(thr))*(yo-yr);
                diff = fabs(LHS - RHS);

                if (diff < MIN_DIFF)
                {
                    // The threshold perhaps should be some units-independent
                    // ration rather than this absolute cut-off value because
                    // diff may be related to the size of mission area. However,
                    // for now, we use this absolute value.

                    // Recycled.
                    bestThr = thr;
                }
                else
                {
                    if (USE_ANALYTICAL)
                    {
                        // Using Law of Sines. Solve the following equation for thr:
                        // (vo*tc)/(sin(thr - objDirRad)) = (vr*tc)/(sin(pi - tho + objDirRad))

                        bestThr = objDirRad;

                        if (fabs(vr) > EPS_ZERO)
                        {
                            checkValue = (vo/vr)*sin(M_PI - tho + objDirRad);

                            if ((checkValue >= -1.0) && (checkValue <= 1.0))
                            {
                                bestThr = asin(checkValue) + objDirRad;
                            }
                        }
                    }
                    else
                    {
                        // Check the LHS and RHS differences for all possible angles.
                        smallestDiff = GT_INFINITY;

                        for (a = -180; a < 180.0; a += 0.1)
                        {
                            thr = DEGREES_TO_RADIANS(a);

                            // Check the time of collision in y
                            checkValue = vo*sin(tho)-vr*sin(thr);

                            if (fabs(checkValue) < EPS_ZERO)
                            {
                                // Bad value
                                continue;
                            }
        
                            tc = -(yo - yr)/checkValue;

                            if (tc < 0)
                            {
                                // Cannot be a negative time
                                continue;
                            }

                            LHS = checkValue*(xo-xr);

                            // Check the time of collision in x
                            checkValue = vo*cos(tho)-vr*cos(thr);

                            if (fabs(checkValue) < EPS_ZERO)
                            {
                                // Bad value
                                continue;
                            }
        
                            tc = -(xo - xr)/checkValue;

                            if (tc < 0)
                            {
                                // Cannot be a negative time
                                continue;
                            }

                            RHS = checkValue*(yo-yr);

                            // Check the difference
                            diff = fabs(LHS - RHS);

                            if (diff < smallestDiff)
                            {
                                smallestDiff = diff;
                                bestThr = thr;
                            }
                        }

                        if (smallestDiff >= MIN_DIFF)
                        {
                            // The threshold perhaps should be some units-independent
                            // ration rather than this absolute cut-off value because
                            // diff may be related to the size of mission area. However,
                            // for now, we use this absolute value.

                            // Solution not found. Just point the vector to the object.
                            bestThr = objDirRad;
                        }
                    }
                }

                vr = (vr < MIN_VALUE)? MIN_VALUE : vr;
                vr = (vr > MAX_VALUE)? MAX_VALUE : vr;
                output.x = vr*cos(bestThr);
                output.y = vr*sin(bestThr);
                rotate_z(output, -(cur_pos.heading));
            }
            
            last_thr = bestThr;
        }

        // Make sure to remember the values for the next time.
        last_xo = xo;
        last_yo = yo;
        last_xr = xr;
        last_yr = yr;
    }

    if (debug || DEBUG_INTERCEPT)
    {
        fprintf(
            stderr,
            "INTERCEPT(%d) output=<%2.2f %2.2f %2.2f>\n",
            robot_id,
            output.x,
            output.y,
            output.z);
    }
}
pend

/**********************************************************************
# $Log: INTERCEPT.cnl,v $
# Revision 1.1.1.1  2006/07/12 13:37:58  endo
# MissionLab 7.0
#
# Revision 1.5  2006/05/02 04:17:18  endo
# TrackTask improved for the experiment.
#
# Revision 1.3  2006/03/30 06:46:45  endo
# Computational load problem solved by Law of Sines.
#
# Revision 1.2  2006/03/01 09:27:39  endo
# Check-in for Type-I Intercept Experiment.
#
# Revision 1.1  2005/05/18 21:19:52  endo
# AuRA.naval added.
#
#
#**********************************************************************/
