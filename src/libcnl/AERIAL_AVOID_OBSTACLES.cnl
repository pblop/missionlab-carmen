#include "cnl.inc"

init
#include "lmadjust.h"
iend

/***********************************************************************/

procedure Vector AERIAL_AVOID_OBSTACLES with
   double	sphere;
   double	safety_margin;
   obs_array    readings;
header
   Vector	repuls;		/* vector along direction of repulsion 
				   for a specific obstacle */
   int		i;		/* current obstacle */
   double	c_to_c_dist;	/* distance from center of robot to center
				   of obstacle */
   double       mag = 0;	/* desired magnatude of a repulsion vector 
				   (repuls) for a specific obstacle */
   double       radius;		/* radius of current obstacle + safety_margin */
   int          first_time=TRUE; 
   double       old_safety_margin = 0;
body
    if( first_time || old_safety_margin != safety_margin )
    {
        /* 
        * Report the safety margin we are using to the console so the
        * graphics can use it for showing virtual collisions
        */
       char buf[80];

       sprintf(buf, "%f",safety_margin);
       exec_put_console_state(SAFETY_MARGIN_MSG,buf);

       old_safety_margin = safety_margin;
       first_time = FALSE;
    }

    VECTOR_CLEAR(output);

    /* readings.size is the number of obstacles
       readings.val is a Vector to the center of the obstacle
       so readings.val.x and readings.val.y are the center numbers.
       readings.r is a corresponding array of each obstacle's radius. 
    */


    for(i=0; i<readings.size; i++)
    {
        /* compute the distance from the center of the robot to the 
	       center of the obstacle in meters */

        c_to_c_dist = len_2d(readings.val[i].center);
        radius = readings.val[i].r + safety_margin;

	// if the uav is not above the obstacle treat it as a 2d obstacle
        if (readings.val[i].center.z >= 0)
	{
		/* Handle the case where within the obstacle */
        	if (c_to_c_dist <= radius )
        	{
	        	/* generate an infinite (around 100000) vector away from the obstacle*/
        	    	mag = INFINITY;

            		if (c_to_c_dist < EPS_ZERO) /* Epsilon Zero (around 0.00001) */
            		{
	            	/* Handle the case where an obstacle is EXACTLY centered
	               	where the robot is as a special case because we can't
	               	use the vector to determine a direction to move.
	               	So, arbitraily choose positive Y direction for vector.
	            	*/

                		readings.val[i].center.y = 1.0;
	        	}
        	}

        	/* handle case where within the linear repulsion zone */
        	else if (c_to_c_dist <= radius + sphere )
        	{
            		/* set the magnitude of the repulsion vector (0...1) based on how 
	           	far we have intruded into the zone.
	           	Magnitude is 0 on outside edge (c_to_c_dist = sphere + radius).
	           	Magnitude is 1 on inside edge (c_to_c_dist = radius)

	           	sphere is the size of the zone.
	           	We are at distance (c_to_c_dist - radius) from the inner edge of
	           	the zone or (sphere - (c_to_c_dist - radius)) from the outer edge.

	           	So, take our distance from the outer edge and divide by the size
	           	of the zone to get a ratio from 0 to 1 with zero at the outside
	           	and 1 at the inside.
	        	*/

            		mag = (sphere - (c_to_c_dist - radius)) / sphere;
        	}

        	/* otherwise, outside obstacle's sphere of influence, so ignore it */
        	else
        	{
	        	mag = 0;
        	}
		readings.val[i].center.z = 0;
	}

	// else the robot is above the obstacle but might need a repulsion up 
	else 
	{
		c_to_c_dist = len_2d(readings.val[i].center);

		// we are ouside the sphere of influence so we ignore this obs
		if (((readings.val[i].center.z *-1) >= sphere) || (c_to_c_dist >= sphere))
		{
			mag = 0;
//			printf("0 mag!\n");
//			printf("sphere: %f    c_to_c_dist: %f     z: %f\n", sphere, c_to_c_dist, readings.val[i].center.z);
		}

		// otherwise we have a linear repulsion from the top
		else if ((readings.val[i].center.z * -1) < sphere) {
			mag = (sphere + readings.val[i].center.z) / sphere;
			readings.val[i].center.x = 0;
			readings.val[i].center.y = 0;
			readings.val[i].center.z = -mag;

		}
	}
			
        	/* if needed, generate a repulsive vector and add it to the running sum */
        if (mag != 0)
        {
	        /* create a unit vector along the direction of repulsion */
            	repuls.x = -readings.val[i].center.x;
            	repuls.y = -readings.val[i].center.y;
		repuls.z = -readings.val[i].center.z;

		// this is to handle vector mangling by unit 3d if the vectors are real small
	//	if (fabs(repuls.x) < .002) repuls.x = 0;
	//	if (fabs(repuls.y) < .002) repuls.y = 0;
	//	if (fabs(repuls.z) < .002) repuls.z = 0;
		
            	unit_3d(repuls);
		

            	/* Set its strength to the value selected */
            	mult_3d(repuls, mag);

            	/* Add it to the running sum */
            	plus_3d(output, repuls);


            	if( debug )
	        {
                	fprintf(stderr, "aerial avoid_obs: <%.1f %.1f %.1f>, %.1f => repulsive vector <%.1f %.1f>\n",
                        readings.val[i].center.x, 
                        readings.val[i].center.y, 
			readings.val[i].center.z,
                        readings.val[i].r,
                        repuls.x, repuls.y);
            	}

            	/* Learning Momentum needs to know the number of obstacles
             	* which affect the robot */
            	affecting_obstacle_history[hist_offset]++;  
        }
  }

    	if( debug )
    	{
        	fprintf(stderr,"avoid_static_obstacles: output vector <%.1f %.1f %.1f>\n",
	            output.x, output.y, output.z);
    	}
pend


/**********************************************************************
# $Log: AERIAL_AVOID_OBSTACLES.cnl,v $
# Revision 1.1.1.1  2006/07/12 13:37:58  endo
# MissionLab 7.0
#
# Revision 1.1  2005/03/27 01:20:25  pulam
# Addition of uxv behaviors
#
# Revision 1.4  2003/06/26 15:52:01  pulam
# Cleaned up behaviors
#
# Revision 1.3  2003/01/15 19:22:29  pulam
# added aerial telop functionality
#
# Revision 1.2  2002/11/25 15:19:37  pulam
# Added additional aerial behaviour AERIAL_MAINTAIN_ALTITUDE
#
# Revision 1.1  2002/11/20 16:56:12  pulam
# Aerial Behaviours
#
# Revision 1.1.1.1  2002/10/29 18:10:14  pulam
# First Revision V2020 Project
#
# Revision 1.11  2000/11/10 23:31:03  blee
# Added the collection of obstacle info for learning momentum
#
# Revision 1.10  1999/05/30 23:48:35  conrad
# *** empty log message ***
#
# Revision 1.11  1995/09/08  14:50:10  doug
# removed include of gt_simulation.h since now in cnl.inc
#
# Revision 1.10  1995/06/28  21:37:10  jmc
# Added RCS id and log strings.
#**********************************************************************/
